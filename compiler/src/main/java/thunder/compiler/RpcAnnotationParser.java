package thunder.compiler;import com.squareup.javapoet.TypeName;import thunder.annotations.*;import thunder.network.util.MessageUtil;import thunder.network.util.StringUtil;import javax.annotation.processing.Filer;import javax.annotation.processing.RoundEnvironment;import javax.lang.model.element.*;import javax.lang.model.type.DeclaredType;import javax.lang.model.type.MirroredTypeException;import javax.lang.model.type.TypeKind;import javax.lang.model.type.TypeMirror;import javax.lang.model.util.Elements;import javax.lang.model.util.Types;import java.lang.annotation.Annotation;import java.util.*;import static javax.lang.model.element.ElementKind.CLASS;import static javax.lang.model.element.ElementKind.INTERFACE;import static javax.lang.model.element.Modifier.PRIVATE;import static javax.lang.model.element.Modifier.STATIC;/** * Created by HandGunBreak on 2016/4/5 - 18:36. * Mail: handgunbreak@gmail.com * Copyright: 杭州医本健康科技有限公司(2015-2016) * Description: 注解解析类 */public class RpcAnnotationParser {    private Types mTypeUtil;    private Elements mElementUtil;    public static RpcAnnotationParser mInstance;    //RpcService注解类型    //private static final List<Class<? extends Annotation>> RPC_SERVICE_ACTION = Arrays.asList(RpcApi.class, RpcGet.class);    private RpcAnnotationParser() {    }    /**     * 单例     *     * @return RpcParser实例     */    public static RpcAnnotationParser getInstance() {        if (mInstance == null) {            synchronized (RpcAnnotationParser.class) {                if (mInstance == null) {                    mInstance = new RpcAnnotationParser();                }            }        }        return mInstance;    }    /**     * 解析     *     * @param roundEnvironment env     * @param filer            filer     * @param types            types     * @param elements         elements     */    public void parser(RoundEnvironment roundEnvironment, Filer filer, Types types, Elements elements) {        mTypeUtil = types;        mElementUtil = elements;        ScopeAnnotatedInterceptorInfo scopeAnnotatedInterceptorInfo = new ScopeAnnotatedInterceptorInfo();        //解析全局拦截器        /*for (Element element : roundEnvironment.getElementsAnnotatedWith(RpcScope.class)) {            if (!isBindingInWrongPackage(RpcScope.class, element)) {                parseRpcScopeAnnotatedInterceptor(scopeAnnotatedInterceptorInfo, element);            }        }*/        //缓存RpcAnnotatedInterfaceInfo对象        Map<Element, RpcAnnotatedInterfaceInfo> rpcAnnotatedInterfaceInfoMap = new LinkedHashMap<>();        //解析@Rpc注解的接口类        for (Element element : roundEnvironment.getElementsAnnotatedWith(Rpc.class)) {            if (!isBindingInWrongPackage(Rpc.class, element)) {                parseRpcAnnotatedInterface(rpcAnnotatedInterfaceInfoMap, scopeAnnotatedInterceptorInfo, element);            }        }        //对@Rpc注解的接口类生成对应的_Rpc类        for (RpcAnnotatedInterfaceInfo rpcAnnotatedInterfaceInfo : rpcAnnotatedInterfaceInfoMap.values()) {            RpcAnnotatedInterfaceGenerator.brewJava(rpcAnnotatedInterfaceInfo, filer);        }        //缓存被@RpcService注解的对象        Map<TypeElement, RpcAnnotatedFieldInfo> rpcAnnotatedFieldInfoMap = new HashMap<>();        Set<? extends Element> restServices = roundEnvironment.getElementsAnnotatedWith(RpcService.class);        for (Element element : restServices) {            parseRpcAnnotatedField(rpcAnnotatedFieldInfoMap, element);        }        //生成被@RpcService注解的属性所在类新类(_ThunderBinder)        RpcBindFieldsClassGenerator.brewJava(rpcAnnotatedFieldInfoMap, filer);    }    /**     * Rpc接口注解解析     *     * @param scopeAnnotatedInterceptorInfo 被@Scope注解的接口类缓存List     * @param element                       被@Scope注解的element     */    private void parseRpcScopeAnnotatedInterceptor(ScopeAnnotatedInterceptorInfo scopeAnnotatedInterceptorInfo, Element element) {        if (!(element instanceof TypeElement)) {            MessageUtil.warning(element, "@%s-annotated class not TypeElement. (%s)", Rpc.class.getSimpleName(), element.getSimpleName());            return;        }        TypeElement typeElement = (TypeElement) element;        //缓存        if (scopeAnnotatedInterceptorInfo != null) {            scopeAnnotatedInterceptorInfo.insertInterceptor(typeElement.getQualifiedName().toString());        }    }    /**     * 解析被@RpcService注解的Field Element     *     * @param rpcAnnotatedFieldInfoMap 缓存被@RpcService注解的 Element类信息     * @param element                  Element     */    private void parseRpcAnnotatedField(Map<TypeElement, RpcAnnotatedFieldInfo> rpcAnnotatedFieldInfoMap, Element element) {        if (isInaccessibleViaGeneratedCode(RpcService.class, element)) {            return;        }        //Field所指类类型        TypeMirror fieldTypeMirror = element.asType();        //Field变量名        String fieldVariableName = element.getSimpleName().toString();        if (!isInterface(fieldTypeMirror)) {            MessageUtil.error(element, "@%s Type which annotated by %s should be Interface type.", fieldVariableName, RpcService.class);        }        //TypeName Field所指类的TypeName        TypeName fieldClassTypeName = TypeName.get(fieldTypeMirror);        //Field所在类的TypeElement(所在类)        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();        //生成RpcFieldBind对象        RpcFieldBind rpcFieldBind = new RpcFieldBind(fieldVariableName, fieldClassTypeName);        //检查是否有缓存        RpcAnnotatedFieldInfo rpcAnnotatedFieldInfo = rpcAnnotatedFieldInfoMap.get(enclosingElement);        if (rpcAnnotatedFieldInfo == null) {            String packageName = getPackageName(enclosingElement);            String className = getClassName(enclosingElement, packageName);            rpcAnnotatedFieldInfo = new RpcAnnotatedFieldInfo(className, packageName, className);        }        rpcAnnotatedFieldInfo.addRpcFieldBind(rpcFieldBind);        rpcAnnotatedFieldInfoMap.put(enclosingElement, rpcAnnotatedFieldInfo);    }    /**     * Rpc接口注解解析     *     * @param rpcServiceClassInfoMap 被@Rpc注解的接口类缓存Map     * @param element                被@Rpc注解的element     */    private void parseRpcAnnotatedInterface(Map<Element, RpcAnnotatedInterfaceInfo> rpcServiceClassInfoMap, ScopeAnnotatedInterceptorInfo scopeAnnotatedInterceptorInfo, Element element) {        //检查注解对象类型        if (!isInterface(element.asType())) {            MessageUtil.error(element, "@%s-annotated class incorrectly in Interface. (%s)", Rpc.class.getSimpleName(), element.getSimpleName());            return;        }        if (!(element instanceof TypeElement)) {            MessageUtil.warning(element, "@%s-annotated class not TypeElement. (%s)", Rpc.class.getSimpleName(), element.getSimpleName());            return;        }        TypeElement typeElement = (TypeElement) element;        //Rpc类信息        RpcAnnotatedInterfaceInfo rpcAnnotatedInterfaceInfo = new RpcAnnotatedInterfaceInfo();        rpcAnnotatedInterfaceInfo.scopeAnnotatedInterceptorInfo = scopeAnnotatedInterceptorInfo;        //缓存        rpcServiceClassInfoMap.put(element, rpcAnnotatedInterfaceInfo);        //包名        rpcAnnotatedInterfaceInfo.packageName = getPackageName(typeElement);        //类名        rpcAnnotatedInterfaceInfo.setClassName(getClassName(typeElement, rpcAnnotatedInterfaceInfo.packageName));        //被Rpc注解的Element(接口类)        rpcAnnotatedInterfaceInfo.setRpcServiceClassElement(typeElement);        //解析Rpc接口类Interceptors拦截器注解        RpcInterceptors interfaceRpcInterceptors = element.getAnnotation(RpcInterceptors.class);        //抽取RpcInterceptors注解的接口类的拦截器        if (interfaceRpcInterceptors != null) {            extractInterceptorsClass(element, interfaceRpcInterceptors, rpcAnnotatedInterfaceInfo);        }        //抽取RpcInterceptor注解的接口类的拦截器        RpcInterceptor interfaceRpcInterceptor = element.getAnnotation(RpcInterceptor.class);        if (interfaceRpcInterceptor!= null) {            extractInterceptorClass(element, interfaceRpcInterceptor, rpcAnnotatedInterfaceInfo);        }        //Rpc接口中的方法Elements        List<? extends Element> enclosedElements = element.getEnclosedElements();        //遍历每个接口方法        for (Element enclosedElement : enclosedElements) {            if (!(enclosedElement instanceof ExecutableElement) || enclosedElement.getKind() != ElementKind.METHOD) {                throw new IllegalStateException(String.format("@%s annotation must be on a method.", enclosedElement.getSimpleName()));            }            //方法Element            ExecutableElement executableElement = (ExecutableElement) enclosedElement;            //方法对象            RpcServiceMethodInfo rpcServiceMethodInfo = new RpcServiceMethodInfo();            //缓存方法对象            rpcAnnotatedInterfaceInfo.addInvokeMethodInfo(rpcServiceMethodInfo);            //方法级单拦截器解析            RpcInterceptor rpcInterceptor = executableElement.getAnnotation(RpcInterceptor.class);            if (rpcInterceptor != null) {                extractInterceptorClass(executableElement, rpcInterceptor, rpcServiceMethodInfo);            }            //方法级多拦截器注解类解析            RpcInterceptors rpcInterceptors = executableElement.getAnnotation(RpcInterceptors.class);            if (rpcInterceptors != null) {                extractInterceptorsClass(executableElement, rpcInterceptors, rpcServiceMethodInfo);            }            //Rpc Action注解类解析            extractRpcServiceAction(executableElement, rpcServiceMethodInfo);            //方法参数解析            extraExecutableParam(executableElement, rpcServiceMethodInfo);        }    }    /**     * 抽取方法参数     *     * @param executableElement    方法Element     * @param rpcServiceMethodInfo 缓存对象     */    private void extraExecutableParam(ExecutableElement executableElement, RpcServiceMethodInfo rpcServiceMethodInfo) {        rpcServiceMethodInfo.mMethodName = executableElement.getSimpleName().toString();        //方法级别的        List<? extends VariableElement> methodParameters = executableElement.getParameters();        rpcServiceMethodInfo.addAllVariableElement(methodParameters);    }    /**     * Rpc Action 解析     *     * @param executableElement    element     * @param rpcServiceMethodInfo 存储     */    private void extractRpcServiceAction(ExecutableElement executableElement, RpcServiceMethodInfo rpcServiceMethodInfo) {        //方法级注解Element        RpcApi rpcApi = executableElement.getAnnotation(RpcApi.class);        if (rpcApi == null) {            return;        }        rpcServiceMethodInfo.url = rpcApi.value();        rpcServiceMethodInfo.connectionTimeout = rpcApi.connectionTimeout();        rpcServiceMethodInfo.readTimeout = rpcApi.readTimeout();        rpcServiceMethodInfo.writeTimeout = rpcApi.writeTimeout();        rpcServiceMethodInfo.useHttps = rpcApi.isHttps();        rpcServiceMethodInfo.methodType = rpcApi.methodType();    }    /**     * 方法级拦截器Interceptor类解析     *     * @param element           element     * @param rpcInterceptor    拦截器注解     * @param insertInterceptor append 接口     */    private void extractInterceptorClass(Element element, RpcInterceptor rpcInterceptor, InsertInterceptor insertInterceptor) {        try {            //拦截器注解            TypeMirror typeMirror = null;            try {                rpcInterceptor.value();            } catch (MirroredTypeException mirroredTypeException) {                typeMirror = mirroredTypeException.getTypeMirror();            }            if (typeMirror != null && !StringUtil.isEmpty(typeMirror.toString())) {                //拦截器类名                String className = typeMirror.toString();                //添加类级自定义拦截器                insertInterceptor.insertInterceptor(className);            }        } catch (Exception exception) {            exception.printStackTrace();        }    }    /**     * 方法级拦截器Interceptors注解类解析     *     * @param element           element     * @param insertInterceptor invokeMethodInfo     */    private void extractInterceptorsClass(Element element, RpcInterceptors interceptor, InsertInterceptor insertInterceptor) {        //拦截器注解        try {            RpcInterceptor[] rpcInterceptors = interceptor.value();            if (rpcInterceptors != null && rpcInterceptors.length > 0) {                for (RpcInterceptor subRpcInterceptor : rpcInterceptors) {                    extractInterceptorClass(element, subRpcInterceptor, insertInterceptor);                }            }        } catch (MirroredTypeException mirroredTypeException) {            MessageUtil.warning(element, "%s- check object.", mirroredTypeException.toString());        }    }    private static boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) {        if (otherType.equals(typeMirror.toString())) {            return true;        }        if (typeMirror.getKind() != TypeKind.EXECUTABLE) {            return false;        }        DeclaredType declaredType = (DeclaredType) typeMirror;        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();        if (typeArguments.size() > 0) {            StringBuilder typeString = new StringBuilder(declaredType.asElement().toString());            typeString.append('<');            for (int i = 0; i < typeArguments.size(); i++) {                if (i > 0) {                    typeString.append(',');                }                typeString.append('?');            }            typeString.append('>');            if (typeString.toString().equals(otherType)) {                return true;            }        }        Element element = declaredType.asElement();        if (!(element instanceof TypeElement)) {            return false;        }        TypeElement typeElement = (TypeElement) element;        TypeMirror superType = typeElement.getSuperclass();        if (isSubtypeOfType(superType, otherType)) {            return true;        }        for (TypeMirror interfaceType : typeElement.getInterfaces()) {            if (isSubtypeOfType(interfaceType, otherType)) {                return true;            }        }        return false;    }    /**     * 检查是否是接口类型     *     * @param typeMirror 待检查的TypeMirror     * @return result     */    private boolean isInterface(TypeMirror typeMirror) {        return typeMirror instanceof DeclaredType && ((DeclaredType) typeMirror).asElement().getKind() == INTERFACE;    }    /**     * 检查注解对象访问权限     *     * @param annotationClass 注解类     * @param element         被注解的元素     * @return 访问权限结果     */    private boolean isInaccessibleViaGeneratedCode(Class<? extends Annotation> annotationClass, Element element) {        boolean hasError = false;        //获取(eg: @Get注解在RecoverApi.java中的方法，返回com.annotation.RecoverApi，即返回当前元素的上一层的Element)        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();        // Verify method modifiers. 检查方法名的修饰符        Set<Modifier> modifiers = element.getModifiers();        if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) {            MessageUtil.error(element, "%s must not be private or static, (%s %s)",                    annotationClass.getSimpleName(), enclosingElement.getQualifiedName().toString(), element.getSimpleName());            hasError = true;        }        // Verify containing methodType.即只能注解类中的方法或者变量，其它则不可，例如方法内的变量注解        if (enclosingElement.getKind() != INTERFACE && enclosingElement.getKind() != CLASS) {            MessageUtil.error(element, "%s must be contained in interface or classes, (%s %s)",                    annotationClass.getSimpleName(), enclosingElement.getQualifiedName().toString(), element.getSimpleName());            hasError = true;        }        // Verify containing class visibility is not private. 类名不能是private        modifiers = enclosingElement.getModifiers();        if (modifiers.contains(PRIVATE)) {            MessageUtil.error(enclosingElement, "@%s must not be contained in private classes. (%s.%s)",                    annotationClass.getSimpleName(), enclosingElement.getQualifiedName(), element.getSimpleName());            hasError = true;        }        return hasError;    }    /**     * 检查注解对象的EnclosingElement是否符合要求     *     * @param annotationClass 注解类     * @param element         被注解的Element     * @return     */    private boolean isBindingInWrongPackage(Class<? extends Annotation> annotationClass, Element element) {        TypeElement enclosingElement = (TypeElement) element;        String qualifiedName = enclosingElement.getQualifiedName().toString();        if (qualifiedName.startsWith(Constants.ANDROID_PREFIX)) {            MessageUtil.error(element, "@%s-annotated class incorrectly in Android framework package. (%s)", annotationClass.getClass().getSimpleName(), qualifiedName);            return true;        }        if (qualifiedName.startsWith(Constants.JAVA_PREFIX)) {            MessageUtil.error(element, "@%s-annotated class incorrectly in Java framework package. (%s)", annotationClass.getClass().getSimpleName(), qualifiedName);            return true;        }        return false;    }    /**     * Uses both {@link Types#erasure} and string manipulation to strip any generic types.     */    private String doubleErasure(TypeMirror elementType) {        String name = mTypeUtil.erasure(elementType).toString();        int typeParamStart = name.indexOf('<');        if (typeParamStart != -1) {            name = name.substring(0, typeParamStart);        }        return name;    }    private String doubleGeneric(TypeMirror elementType) {        String name = elementType.toString();        int typeParamStart = name.indexOf('<');        int typeParamEnd = name.indexOf('>');        if (typeParamStart != -1 && typeParamEnd != -1 && typeParamEnd > typeParamStart) {            name = name.substring(typeParamStart + 1, typeParamEnd);        }        return name;    }    /**     * 获取类名     *     * @param type        TypeElement对象     * @param packageName 包名     * @return 类名     */    private String getClassName(TypeElement type, String packageName) {        return type.getQualifiedName().toString().substring(packageName.length() + 1);    }    /**     * 获取某个类型的包名     *     * @param type TypeElement对象     * @return 包名     */    private String getPackageName(TypeElement type) {        return mElementUtil.getPackageOf(type).getQualifiedName().toString();    }}